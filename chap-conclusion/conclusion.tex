\chapter {Conclusion and Future Work}
\label{ch:conclusion}
\lhead{\chaptername \ \ref{ch:conclusion}.\ \emph{Conclusion and Future Work}} %

\section {Concluding Remarks}

Regarding three important problems existed with existing NFV systems, this thesis discusses the design and implementation of \textit{ScalIMS}, \nfactor and \netstar, which are capable of solving the three problems through an empirical approach.

\textit{ScalIMS} scales control-plane and data-plane service chains of IMS systems across geo-distributed datacenters by combining the benefits of proactive and reactive scaling. Evaluation of our prototype implementation on IBM SoftLayer cloud shows that \textit{ScalIMS} effectively reduces the total number of VNF instances provisioned while guaranteeing excellent QoS.

\nfactor~exploits actor model to achieve transparent and highly efficient failure resilience and employs an efficient actor runtime for improving both the packet processing and message passing performance. Our experiments show that \nfactor~achieves good scalability and high packet processing speed, as well as fast flow migration and failure recovery.

\netstar~represents first attempt to bring the future/promise abstraction to the NF dataplane for flow processing. Using \netstar, asynchronous programming in NFs is made easy, elegant, while good packet processing performance is still guaranteed. Our extensive evaluation shows that \netstar~can effectively simplify asynchronous programming asynchronous in NFs, while easily achieve line-rate packet processing for NFs.

\section {Future Work}

We identify two important research directions that are inspired by the study of this thesis.

\subsection{Bring Paxos-based Fault-tolerance to NFV}

An important application of both \nfactor~and \netstar~is to make NFs fault-tolerant. \nfactor~achieves fault-tolerance by constantly check-pointing the per-flow state of a flow actor to an replica actor, while \netstar~resists to failures by saving and updating important per-flow state to an external in-memory storage system.

Even though both method can improve the failure-resilience performance of NFV system, they can only tolerate the failure of a single NF instance that is correctly replicated. In practice, it is possible for multiple servers to fail concurrently, especially when the servers running both the replicated NFs and the replicas are placed inside the same rack within a single datacenter. In that case, the NFs will never be correctly replicated due to the loss of important replication states from the replica.

An important method for fighting against this kind of failure is to run Paxos algorithm, where a cluster of server instances form a consensus group. With Paxos, the cluster can tolerate $N/2$ failured server instances for $N$ server instances. Existing work, like Parrot \cite{}, has discussed replicating general-purpose server systems using Paxos algorithm. However, replicating NF instances using Paxos raises a unique challenge.

NFs are usually design to work with a high input packet rate. A typical NF usually needs to process millions of packet per-second. Such a high input packet rate poses a challenge for existing Paxos system, as existing Paxos system does not support such a high throughput.

Our work on \netstar~raises potential opportunities for bringing Paxos-based fault-tolerance to NFV. Implementing high-performance Paxos algorithm requires non-trivial asynchronous programming. Programming on top of \netstar~can effectively simplifies the implementation. But to build a practical system, we still need to find out architectural and algorithmic breakthroughs for Paxos.

\subsection{Building Formally Verified NFs}

An important research motivation for this entire thesis is to leverage modern programming paradigms to improve the design of NFV system. The thesis discusses how to apply actor model and future/promise paradigm to improve the performance of failure resilience and simplify the programming of high-performance asynchronous NFs. Besides these two programming paradigms, another important paradigm that is worth for future exploration is formal verification.

Formal verification has drawn important attention in recent years. A piece of software that is formally verified has the strongest guarantee for the absense of various bugs. We believe that formal verification is extremely important for NFV, as NFs are important access gateways of the underlying services. Therefore any software bugs and risks of the NF may render the entire service protected by the NF useless.

In particular, a recent break-through in the formal verification of NFs is VigorNAT \cite{}. VigorNAT combines model-checking with theorem proving: it uses model-checking to check stateless part of a NF, including the DPDK framework. It then relies on theorem proving to verify the correctness of important data-structures used by the NAT. By combining the result of model-checking and theorem proving, the VigorNAT obtains a completely verified NF.

There are two major problems associated with VigorNAT. First, VigorNAT treats the entire DPDK library as the trusted computing base. VigorNAT assumes that DPDK is correct and does not care about potential bugs and error conditions raised by DPDK library. However, DPDK itself is an extremely complicated library. It is used to retrieve network packets from the NIC card and serves as the the core of many modern, high-performance NFs. To further improve the reliability of formally verified NFs, the DPDK library must be removed from the trusted computing base. Second, the formal verification of the data-structures used by VigorNAT can only preserves its correctness up to the semantics of C programming language. There is no guarantee that the compiled machine code is correct.

We believe that to further improve the reliability of formally verified NFs, an effective approach is to rely on recent advancement of formal verification techniques, especially the VST project. The VST project applies formal verification directly to C code, and guarantees that the compiled machine code is correct. Also, a recent paper illustrating the operational mode of DPDK library gives opportunity for building a formally verified library with similar functioanlities as DPDK. 

%Implementing high-performance Paxos algorithm inside NFs requires non-trivial asynchronous programming, which
