\chapter {\netstar: A Future/Promise Framework for Asynchronous Network Functions}
\label{ch:netstar}
\lhead{\chaptername \ \ref{ch:netstar}.\ \emph{\netstar}} %

This chapter discusses the design and implementation of \netstar. In section \ref{sec:netstar-introduction}, we give a brief introduction to \netstar~system. The motivation for designing \netstar~and a tutorial for future/promise paradigm is shown in section \ref{sec:netstar-motivation}. The overall architecture of~\netstar~framework is presented in section \ref{sec:netstar-overview}, followed by a detailed description of the core component of \netstar, namely async-flow interface, in section \ref{sec:netstar-framework}. Section \ref{sec:netstar-implementation} discusses four representative NFs that we implemented with \netstar~and their performances are evaluated in section \ref{sec:netstar-evaluation}. A discussion about \netstar~framework is then given in section \ref{sec:netstar-discussion}. This chapter concludes by presenting a chapter summary in section \ref{sec:netstar-conclusion}.

\section{Introduction} \label{sec:netstar-introduction}

Network Functions (NFs) are more than simple packet processors that perform various transformations on each received packet. Modern NFs, \eg, firewall \cite{201545}, NAT \cite{201545}, IDS \cite{bro}, and proxies \cite{haproxy, project-clearwater}, often need to contact external services while processing network flows, \eg, for
%retrieving useful information from an external database, querying a DNS service
querying external databases~\cite{telephone-number-mapping, bro-scripting-tutorial}, or saving critical per-flow states on external reliable storage (for failure resilience purposes) \cite{201545}. To ensure high-speed packet processing while executing external queries, these NFs must fully exploit asynchronous programming: after generating a request to an external service, the NF should not block and wait for the response in a synchronous fashion; instead, it can save the current processing context and register an event handler function to handle the response upon its return, and switch to process other packets, potentially generating additional asynchronous requests.

%To implement efficient L4 flow processing, such an NF must fully utilize flow-level asynchrony: after processing a single packet in a flow \chuan{while no further upcoming packets are received in the flow?}, the NF should move on to process packets of other flows for xxx \chuan{give the purpose}, while retaining %without undermining
% the processing context of the original flow \chuan{explain what context is referring to}. Various NF software \cite{snort, 201546, haproxy} uses callback-based asynchronous programming to achieve flow-level asynchrony: after processing a packet, the NF saves context information of the current flow and switches to process other flows; when a new packet of the first flow arrives, the saved context is retrieved and a pre-determined callback function \chuan{not clear what `pre-determined' means and briefly describe what the callback function does} is invoked to serve the flow.


%Some modern NFs may need to contact external services, \eg, to be resilient to failures \cite{201545} \chuan{not clear why `to be resilient to failures' is relevant to `contact external services'}, collaborate with other NFs \cite{3gpp-ims} \chuan{be more concrete in this example by giving an collaboration example},  and retrieve useful information from a DNS server \cite{telephone-number-mapping, bro-scripting-tutorial}. For such NFs, besides flow-level asynchrony, request-level asynchrony is needed, that the NF switches to process the following packets in the same flow without waiting for handling of the previous ones (through the external services) to complete \chuan{improve my description of `request-level asynchrony': is it based on packets or some sort of `requests'?}.

For example, to detect whether a file transmitted over a TCP connection contains a piece of malware, a Bro IDS \cite{bro} issues a DNS query containing the SHA1 hash \cite{sha1} of the file extracted from the reconstructed byte stream of the TCP flow to a Malware Hash Registry (MHR) \cite{MHR}. Then, the MHR generates a DNS response indicating whether the hash matches that of some known malware. To ensure high performance, the Bro IDS does not block and wait for the MHR response to arrive. Instead, it registers a callback function to handle the MHR response upon its receipt, in an asynchronous fashion, and switches to process other flows/packets or handle other generated events (new packet arrival, new reconstructed payload, etc. \cite{paxson1999bro}).
%\chuan{add two figures to illustrate flow-level asynchrony and request-level asynchrony in the above two paragraphs using two NF examples (switching among multiple flows, switching among packets in the same flow while accessing external devices).}

Compared with synchronous NF programs, asynchronous NF implementation using callbacks is significantly more efficient in packet processing, as it does not waste important CPU time. However, callback-based asynchronous programming has some inherent drawbacks that can prevent developers from building NFs with richer functionalities.
%, where asynchronous operations are often.

\textit{First,} compared to a synchronous program, a callback-based asynchronous program is harder to implement and reason about. %When a series of asynchronous operations are concatenated together,
Such a program may define multiple callback functions, scattered within different source files, to achieve a series of asynchronous operations. For example, the Bro IDS can be configured to detect malware in flows using two nested callback functions, a first callback function to handle the reply from a local database query which may trigger another callback function to handle the reply to a MHR query~ (Sec.~\ref{sec:bro}); and a NAT may replicate important per-flow states in an external database using 4 consecutive callbacks, to read from and write to a remote database while a TCP connection through the NAT is being established \cite{201545}. Dealing with multiple callbacks scattered in different source files can be confusing, and make it more difficult for a programmer to trace the execution order of the program. %, which may increase the possibility for introducing software bugs.

%disrupts the control flow of the program \cite{}: inside one callback function, the programmer may lose track of execution order of the program, making.
%On the other hand, concatenating a series of asynchronous operations can be important to modern NF design, as modern NFs can leverage this programming pattern to detect transmitted malwares (Sec.~\ref{sec:bro}) and replicate important per-flow state to recover from failure \cite{}.

%\textit{Second,} retrieving saved context information after registering a callback is a non-trivial job, which can be error-prone. Since an asynchronous program immediately switches to other tasks after registering a callback, the program must save the context before switching, and properly recover the context when the callback is eventually invoked. \chuan{explain more clearly what the context includes, such that readers can understand the following claim better} Failing to do so may lead to invalid memory access and program crash \cite{lu2008learning}. However, tracking context information is not easy, especially when the context is passed among multiple callback functions created due to a serious of asynchronous operations \chuan{explain more clearly why `tracking context information is not easy' or `retrieving saved context information after registering a callback is a non-trivial job'}.

\textit{Second,} visiting saved context information inside a registered callback can be error-prone. Since an asynchronous program immediately switches to other tasks after saving the context and registering a callback, the program must ensure that the saved context is not accidentally freed until the callback is invoked. Failing to do so may lead to invalid memory access and program crash. However, when multiple callback functions are used, the programmer may accidentally free the context if he fails to correctly trace the execution order of the callbacks.

\textit{Third,} redundant error handling code may be introduced in a callback-based asynchronous program. Since exceptions may happen when waiting for the external response, the program must properly handle the exceptions by either registering an error handling function or implementing exception handling logic in the callback registered to handle the response. When a series of asynchronous operations are executed, the programmer needs to add exception handling logic for each asynchronous operation. %failing to handle any may lead the program into incorrect state.
 Since the asynchronous operations/callback functions may well be scattered among multiple files, duplicate error handling code may need to be added in multiple places.
%It becomes tedious to redundantly add error handling code when multiple callback functions are defined

% First, the packet access pattern of a NF sometimes requires multiple asynchronous operations to be chained together in order to process a single packet \cite{201545}. This requires defining multiple callback functions and saving multiple contexts, which may significantly increase the number of the lines of code used for implementing simple NF logic. Second, due to the use of multiple callback functions, the control flow of the program is disrupted, making it hard to write and reason about the correctness of the resulting NF logic. Third, exception handling in existing event-driven framework can be repetitive, as each callback function needs to carefully handle possible error conditions. Finally, most existing event-driven programming framework is based on C programming language, which does not expose a safe programming interface. When the callback function is invoked, the callback function can literally modify arbitrary program state, which may crash the entire NF program if not carefully programmed.

%\chuan{clarify why using a more advanced programming abstraction is a natural solution: have people been aware of the above problems with callbacks and used coroutine or future/promise as the solution in other domains? If so, you should explain so, give examples and add citations.}

People have recognized the problems with callbacks when building event-driven systems such as web browsers \cite{gallaba2015don, kambona2013evaluation}, programming language runtime systems \cite{syme2011f}, web servers \cite{tornado-web-server} and database servers \cite{rethinkdb}. Their solution to counter the problems is to use a more advanced programming abstraction, such as the coroutine \cite{coroutine} and the future/promise paradigm
\cite{li2007combining, claessen1999poor, wtf}. Coroutine is a user-space cooperative thread that is able to execute asynchronous program in a fully synchronous fashion. %making asynchronous code easy to implement compared with callbacks.
 However, the coroutine switching time may cause and suffer considerable overhead in NFs processing a large number of concurrent network flows.
In contrast, the future/promise paradigm uses special runtime objects, futures, promises and continuation functions, to mimic synchronous programming while being fully asynchronous. Besides making asynchronous program easier to implement, the future/promise abstraction can also reduce redundant error handling code by effectively propagating exceptions to a consolidate error handling logic.% reduce redundant error handling code.  \chuan{explain more why future/promise could be a better solution to resolve the three problems with callbacks}.


Though the future/promise paradigm is promising, the future/promise abstraction had only existed in high-level programming languages such as F\# \cite{syme2011f}, Haskell \cite{li2007combining} and OCaml \cite{wtf}. It is known that high-level programming languages are not suitable for developing NF software due to their lower runtime efficiency as compared to C/C++-based implementation, and unpredictable processing delay caused by their garbage collectors \cite{199352}. A recent open-source C++ library, Seastar \cite{seastar}, is implementing the future/promise paradigm to build high-performance database servers \cite{scylladb}. The library is integrated with DPDK and provides a customized user-space TCP/IP stack for high-speed database queries. However, it does not expose any interface to manipulate raw network packets, and designing such an interface, which effectively processes network packets without diminishing the power of the future/promise abstraction, is non-trivial. A straightforward design may directly expose a regular packet handler function, that is invoked for each received packet. However, such a design falls back to callback-based asynchronous programming and leaves no room for utilizing the future/promise abstraction.
%, as a naive implementation may degrade the future/promise abstraction into regular callback functions. \chuan{clarify why `a naive implementation may degrade the future/promise abstraction into regular callback functions'.}

This paper proposes \netstar, a future/promise-based programming framework for simple, elegant asynchronous programming in NFs. %For the first time, \netstar~brings efficient future/promise abstraction to the dataplane software.
\netstar~enables programming a series of asynchronous operations (when processing dataplane packets) in a manner similar to implementing a simple synchronous program, while not incurring any performance degradation due to blocking as in a synchronous program.

% \chuan{The following two paragraphs on technical contributions are non-satisfactory: think hard and write again; you should explain more on how our design addresses the three callback problems listed above}

The power of \netstar~is mainly attributed to a programming interface that we design, the async-flow interface, which effectively combines network packet handling process with the future/promise abstraction. The async-flow interface is powered by a simulated packet processing loop, and uses the returned future objects from a packet handler function for implementing core NF processing logic. % to concatenate asynchronous operations.
 With this interface, programmers can simplify the implementation of complex asynchronous operations in NFs by chaining a series of continuation functions, which mimics a synchronous program. Due to the future/promise paradigm, programmers can avoid redundant error handling logic but use a set of consolidate error handling code, allowing them to focus more on the core NF processing logic. The async-flow interface also simplifies context management: a programmer only needs to keep track of a pointer to a context object, and subsequent visits to the context object is guaranteed to be safe.


% is used to implement complex asynchronous operations when processing raw packets and build a wide range of real-world NF applications. Instead, async-flow interface simulates a regular packet processing loop which is sequentially invoked to process each flow packet. Within the simulated loop, NF application can create arbitrarily complex asynchronous operation chains using future/promise abstraction to handle the flow packet.

%\textit{Seastar Library.} We patch Seastar to expose an interface for receiving and sending raw network packets, paving the way for building various NFs. In addition, we eliminate an extra packet copy by replacing the default Seastar packet object with a fast packet representation, which improves the raw packet processing throughput significantly.


%to effectively leverage future/promise abstraction to process dataplane packets, we have designed async-flow interface. The interface captures a wide range of real-world NF requirements. Using this interface, the NF program can execute complicated asynchronous operations with ease.

% In this paper, we proposed NetStar framework, which is designed to improve asynchronous programming in NF software. In particular, NetStar handles asynchronous operations of middleboxes in a way that is both efficient and manageable. Asynchronous operations in NetStar are accomplished through through callbacks, making NetStar highly efficient. However, the callbacks in NetStar are used in an implicit way that mimics the style of synchronous operations, making them easy to program with and reason about. NetStar's power comes from the promise-continuation programming model provided by Seastar \cite{seastar} and advanced C++14 features, such as lambda expression and move semantics.\chuan{use one sentence to explain what is seastar}

%Based on the advanced programming model, we design a general purpose asynchronous flow abstraction that can precisely capture a wide rage of real-world NF requirements. Using the asynchronous flow abstraction, the processing task of the flow can pause at any time to perform asynchronous operations and resume normal processing when the asynchronous operation finishes. Our model is memory safe and only exposes events that the user registers.

To evaluate the performance of \netstar, we build a number of NFs using the framework, including four NFs from the StatelessNF paper \cite{201545}, an HTTP reverse proxy, an IDS and a malware detector. %...\chuan{update the list according to what you have}.
With extensive experiments, we show that NFs based on \netstar~use substantially fewer lines of code to implement asynchronous packet processing, as compared to callback-based implementation, while delivering sufficiently good performance in terms of packet processing throughput and latency. We also compare \netstar~with a coroutine based implementation, and show that the coroutine is a less desirable paradigm for implementing NFs processing a large number of concurrent network flows. %The source code of~\netstar~is available at \cite{netstar-source}.
%Moreover, we quantitatively evaluate the number of lines code of NFs implemented using \netstar~with NFs implemented using traditional call-backed asynchronous programming method. Our quantitative study shows that for NFs that need to perform asynchronous operations, \netstar~can effectively reduce the lines of code needed for implementing the core logic NF, by up to more than 20\%.

%\chuan{the following contributions are lame so remove} In summary, this paper makes the following contributions. (i) We are the first to introduce future/promise abstraction into dataplane software for handling complex asynchronous interactions, which can be important to modern NFs with varying real-world needs. chuan: but SeaStar can achieve it already (ii) We have designed and implemented async-flow interface, which exposes the full power of future/promise abstraction and enable NF applications to implement complex asynchronous operations. (iii) We implement several NFs that are of important industrial and research values using NetStar, verify they can achieve good performance while enjoy a simplified implementation.

% We make the following contribution in this paper:

% First, we extend Seastar into a new framework for efficiently building asynchronous NFs. Second, we define a general purpose asynchronous flow model that can capture the requirement of a wide-range of real-world middleboxes. Finally, we use NetStar to build some practical middleboxes and quantitatively evaluate its effectiveness in reducing the lines of implementation code.
