\section{Related Work}

%\noindent \textbf{Advanced Programming Frameworks for NFs.}
NetBricks proposes a fast and secure framework based on the Rust \cite{199352} language for building NFs. %NetBricks provides a high-level abstraction for building fast packet processing pipelines, but it does not address how to simplify asynchronous programming in NFs.
\netstar~leverages future/promise abstraction to process dataplane traffic, and simplifies asynchronous programming with the async-flow interface.
P4 \cite{bosshart2014p4} provides a high-level programming language for describing dataplane packet processing pipelines, but it has no intrinsic support for manipulating dataplane packets asynchronously as in \netstar. The BESS virtual switch \cite{bess} and the Click software router \cite{kohler2000click} share a similar design philosophy, which is to construct NFs by concatenating multiple simpler processing modules. It is possible to integrate callback-based asynchronous interfaces into both BESS and Click to handle dataplane packets asynchronously, but implementation effort would be more significant than in \netstar, due to the inherent limitation of callback functions when compared with future/promise abstraction.
mOS \cite{201546} proposes a unified interface for managing connection oriented middleboxes. Using its interface, a middlebox can extract application-level payload and apply different callback functions to process the payload. \netstar~shares a similar event layer as in mOS, where the packet is preprocessed to expose interested events to the core NF processing logic; however, \netstar~uses the future/promise abstraction for event handling, and can effectively simplify implementation in case the NF requires to contact external services.

%\noindent \textbf{NFs with Asynchronous Operations.}
%The trend of NFV adds more requirement to NFs.
Except for being fast, NFs should be designed to resist various failures and handle large workload. %work in a large cluster.
StatelessNF \cite{201545} proposes a new architecture that separates the storage of per-flow states from the processing of packets. This advanced architecture requires efficient and simplified asynchronous programming support, which is nicely provided by \netstar. OpenNF \cite{gember2015opennf}, Split/Merge \cite{rajagopalan2013split} and PEPC \cite{Qazi:2017:HPP:3098822.3098848} all use flow migration for dynamical scaling of NF instances (by migrating flows out of hotspots). Implementation of a flow migration protocol typically involves complex asynchronous interactions, and \netstar~can be potentially useful to simplify flow migration implementation.

%\chuan{most discussions in the following duplicate with what was introduced earlier in the paper. Comment out this paragraph and you can move necessary introduction to future/promise, Seaster to earlier part of the paper}
%\noindent \textbf{The History of Future/Promise Abstraction.} The history of future/promise abstraction dates back to 1980s \cite{}. Over the years, the implementation technique of future/promise abstraction has evolved a lot, but most implementation appears in high-level functional programming languages like OCaml \cite{} and Haskell \cite{}, limiting its applicability to dataplane packet processing. The future/promise abstraction used in this paper belongs to a special monadic structure, which is first proposed by ...\cite{}. ... \cite{} and ...\cite{} implement such a future/promise abstraction in OCaml and Haskell, respectively. Recently, Seastar \cite{} implements a fast future/promise abstraction using C++, paving the way for applying it to dataplane packet processing. Besides C++, Rust programming language \cite{} also has a fast future/promise abstraction implementation \cite{}, it is possible to port NetStar to Rust to enjoy a safe execution environment, but it is beyond the scope of this paper.
