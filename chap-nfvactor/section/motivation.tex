\section{Motivations for Using the Actor Model}

Systems that enable failure resilience \cite{sherry2015rollback,rajagopalan2013pico} and flow migration \cite{rajagopalan2013split, gember2015opennf} typically achieve a low level of parallelism: a centralized controller governs the migration of all the flows among multiple NF instances, while an entire NF process has to be checkpointed for replication. If we can improve the parallelism by providing an efficient per-flow execution environment, then each flow can migrate and replicate itself without full-process checkpointing and centralized migration control, leading to improved resilience performance. Such a per-flow execution environment can be modelled by actors.

The actor programming model \cite{actor-wiki, erlang, akka, caf} has a long history of being used to construct massive, distributed systems \cite{actor-wiki, akka, newell2016optimizing, AnalysisActor}. Each actor is a lightweight and independent execution unit. In the simplest form, an actor contains a global unique address, a message queue (mailbox) for accepting incoming messages, several message handlers and an internal actor state (\eg, statistic counter, number of outgoing requests). An actor can send messages to other actors by referring to their addresses, process incoming messages using message handlers, update its internal state, and create new actors. Multiple actors run asynchronously as if they were running in their own threads, simplifying programmability of distributed protocols and eliminating potential race conditions that may cause system crash. Actors typically run on a powerful runtime system \cite{caf}, which can schedule millions of lightweight actors simultaneously.

The actor model is a natural fit to provide a per-flow execution environment for resilient NFV system. We can create one actor as the basic execution environment for a flow and equip the actor with necessary message handlers for service chain processing, flow state replication and migration. Then each actor can process network packets and handle its own resilience by creating new actors and exchanging messages with other actors.

There are several popular actor frameworks \cite{akka, erlang, Orleans, caf}, but none of these frameworks are optimized for building NFV systems. In our initial implementation, we built \nfactor~on top of libcaf \cite{caf}, one of the fastest actor system \cite{chs-rapc-16}. But the overall performance turned out to be less than satisfactory, due to its actor scheduling strategy and the use of kernel networking stack. This inspires us to customize a high-performance actor runtime system (Sec.~\ref{sec:implementation}) for \nfactor.
